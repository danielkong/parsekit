@symbols = '!=' '<=' '>=';
 
@start = expr;
expr = orExpr;
 
orExpr = andExpr orTerm*;
orTerm = 'or'! andExpr {
	BOOL rhs = POP_BOOL();
	BOOL lhs = POP_BOOL();
	PUSH_BOOL(lhs || rhs);
};
 
andExpr = relExpr andTerm*;
andTerm = 'and'! relExpr {
	BOOL rhs = POP_BOOL();
	BOOL lhs = POP_BOOL();
	PUSH_BOOL(lhs && rhs);
};
 
relExpr   = callExpr relOpTerm*;
relOp     = '<' | '>' | '=' | '!=' | '<=' | '>=';
relOpTerm = relOp callExpr {
	NSInteger rhs = POP_INT();
	NSString  *op = [POP_TOK() stringValue];
	NSInteger lhs = POP_INT();

	     if ([op isEqualToString:@"<"])  PUSH_BOOL(lhs <  rhs);
	else if ([op isEqualToString:@">"])  PUSH_BOOL(lhs >  rhs);
	else if ([op isEqualToString:@"="])  PUSH_BOOL(lhs == rhs);
	else if ([op isEqualToString:@"!="]) PUSH_BOOL(lhs != rhs);
	else if ([op isEqualToString:@"<="]) PUSH_BOOL(lhs <= rhs);
	else if ([op isEqualToString:@">="]) PUSH_BOOL(lhs >= rhs);
};

callExpr = primary ('(' argList? ')')?;
argList = atom (',' atom)*;
 
primary = atom | '(' expr ')';
atom = obj | literal;
 
obj = id member*;
id = Word;
member = '.' id;
 
literal = {LA(1) != TOKEN_KIND_YES_UPPER}? bool // this predicate makes no sense. it's just for testing expr predicates.
		| Number { PUSH_FLOAT([POP_TOK() floatValue]); }
	    | QuotedString {
			PKToken *tok = POP();
			PUSH(tok.stringValue);
		}
		;

bool = 'yes' {POP(); PUSH_BOOL(YES);} 
	 | 'YES' {POP(); PUSH_BOOL(YES);}
	 | 'no'  {POP(); PUSH_BOOL(NO);}
	 | { return ![[LT(1) stringValue] isEqualToString:@"NO"]; }? 'NO'  {POP(); PUSH(@(0));} // this predicate makes no sense. it's just for testing stat predicates.
	 ;
