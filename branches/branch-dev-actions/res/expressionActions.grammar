@symbols = '!=' '<=' '>=';
 
@start = expr;
expr = orExpr;
 
orExpr = andExpr orTerm*;
orTerm = 'or'! andExpr {
	id rhs = POP();
	id lhs = POP();
	PUSH(@([lhs boolValue] || [rhs boolValue]));
};
 
andExpr = relExpr andTerm*;
andTerm = 'and'! relExpr {
	id rhs = POP();
	id lhs = POP();
	PUSH(@([lhs boolValue] && [rhs boolValue]));
};
 
relExpr   = callExpr relOpTerm*;
relOp     = '<' | '>' | '=' | '!=' | '<=' | '>=';
relOpTerm = relOp callExpr {
	id rhs = POP();
	PKToken *op = POP();
	id lhs = POP();
	
	NSString *str = op.stringValue;
	
	     if ([str isEqualToString:@"<"])  PUSH(@([lhs integerValue] <  [rhs integerValue]));
	else if ([str isEqualToString:@">"])  PUSH(@([lhs integerValue] >  [rhs integerValue]));
	else if ([str isEqualToString:@"="])  PUSH(@([lhs integerValue] == [rhs integerValue]));
	else if ([str isEqualToString:@"!="]) PUSH(@([lhs integerValue] != [rhs integerValue]));
	else if ([str isEqualToString:@"<="]) PUSH(@([lhs integerValue] <= [rhs integerValue]));
	else if ([str isEqualToString:@">="]) PUSH(@([lhs integerValue] >= [rhs integerValue]));
};

callExpr = primary ('(' argList? ')')?;
argList = atom (',' atom)*;
 
primary = atom | '(' expr ')';
atom = obj | literal;
 
obj = id member*;
id = Word;
member = '.' id;
 
literal = {LA(1) != TOKEN_KIND_YES_UPPER}? bool // this predicate makes no sense. it's just for testing expr predicates.
		| Number {            
			PKToken *tok = POP();
            PUSH(@(tok.floatValue));
		}
	    | QuotedString {
			PKToken *tok = POP();
			PUSH(tok.stringValue);
		}
		;

bool = 'yes' {POP(); PUSH(@(1));} 
	 | 'YES' {POP(); PUSH(@(1));}
	 | 'no'  {POP(); PUSH(@(0));}
	 | { PKToken *tok = LT(1); return ![tok.stringValue isEqualToString:@"NO"]; }? 'NO'  {POP(); PUSH(@(0));} // this predicate makes no sense. it's just for testing stat predicates.
	 ;
