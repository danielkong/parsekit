@start               = statement+;
statement            = decl | tokenizerDirective;
tokenizerDirective   = at ~startSym equalSign (Word | QuotedString)+ semi!;
decl                 = production equalSign action? expr semi!;
production           = startProduction | varProduction;
startProduction      = at startSym!;
varProduction        = LowercaseWord;
expr                 = term orTerm*;
term                 = semanticPredicate? factor nextFactor*; // lookahead set for 'nextFactor' here has problems related to upper and lowercase word
orTerm               = '|' term;
factor               = (phraseStar | phrasePlus | phraseQuestion | phrase) action?; // might wanna left factor this bad boy. that's a lot of 'phrase' speculating
nextFactor           = factor;

phrase               = primaryExpr predicate*;
phraseStar           = phrase '*'!;
phrasePlus           = phrase '+'!;
phraseQuestion       = phrase '?'!;

action               = %{'{', '}'};
semanticPredicate    = %{'{', '}?'};

predicate            = (intersection | difference);
intersection         = '&'! primaryExpr;
difference           = '-'! primaryExpr;

primaryExpr          = negatedPrimaryExpr | barePrimaryExpr;
negatedPrimaryExpr   = '~'! barePrimaryExpr;
barePrimaryExpr      = atomicValue | subSeqExpr | subTrackExpr;
subSeqExpr           = '(' expr ')'!;
subTrackExpr         = '[' expr ']'!;
atomicValue          = parser discard?;
parser               = pattern | literal | variable | constant | delimitedString;
discard              = '!'!;
pattern              = %{'/', '/'} | %{'/', '/i'};
delimitedString      = delimOpen QuotedString (','! QuotedString)? '}'!;
literal              = QuotedString;
variable             = LowercaseWord;
constant             = UppercaseWord;
delimOpen		     = '%{';

at 					 = '@'!;
startSym 			 = 'start';
equalSign 			 = '=';
semi				 = ';';
