@start               = statement*;
statement            = tokenizerDirective | decl;
tokenizerDirective   = '@'! ~'start' '=' (Word | QuotedString)+ ';'!;
decl                 = production '=' action? expr ';'!;
production           = startProduction | varProduction;
startProduction      = '@'! 'start'!;
varProduction        = LowercaseWord;
expr                 = term orTerm*;
term                 = semanticPredicate? factor nextFactor*;
orTerm               = '|' term;
factor               = (phrase | phraseStar | phrasePlus | phraseQuestion) action?;
nextFactor           = factor;

phrase               = primaryExpr predicate*;
phraseStar           = phrase '*'!;
phrasePlus           = phrase '+'!;
phraseQuestion       = phrase '?'!;

action               = %{'{', '}'};
semanticPredicate    = %{'{', '}?'};

predicate            = (intersection | difference);
intersection         = '&'! primaryExpr;
difference           = '-'! primaryExpr;

primaryExpr          = negatedPrimaryExpr | barePrimaryExpr;
negatedPrimaryExpr   = '~'! barePrimaryExpr;
barePrimaryExpr      = atomicValue | subSeqExpr | subTrackExpr;
subSeqExpr           = '(' expr ')'!;
subTrackExpr         = '[' expr ']'!;
atomicValue          = parser discard?;
parser               = pattern | literal | variable | constant | delimitedString;
discard              = '!';
pattern              = %{'/', '/'};
delimitedString      = delimOpen QuotedString (',' QuotedString)? '}'!;
literal              = QuotedString;
variable             = LowercaseWord;
constant             = UppercaseWord;
delimOpen		     = '%{';