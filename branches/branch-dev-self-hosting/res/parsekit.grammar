@start               = statement+;
statement            = decl | tokenizerDirective;
tokenizerDirective   = '@'! ~'start' '=' (Word | QuotedString)+ ';'!;
decl                 = production '=' action? expr ';'!;
production           = startProduction | varProduction;
startProduction      = '@'! 'start'!;
varProduction        = Word;
expr                 = term orTerm*;
term                 = semanticPredicate? factor nextFactor*;
orTerm               = '|' term;
factor               = phrase cardinality? action?;

nextFactor           = factor;
phrase               = primaryExpr predicate*;

cardinality 		 = '*'! {[self fireAssemblerSelector:@selector(parser:didMatchPhraseStar:)];}
	        		 | '+'! {[self fireAssemblerSelector:@selector(parser:didMatchPhrasePlus:)];}
					 | '?'! {[self fireAssemblerSelector:@selector(parser:didMatchPhraseQuestion:)];};

action               = %{'{', '}'};
semanticPredicate    = %{'{', '}?'};

predicate            = (intersection | difference);
intersection         = '&'! primaryExpr;
difference           = '-'! primaryExpr;

primaryExpr          = negatedPrimaryExpr | barePrimaryExpr;
negatedPrimaryExpr   = '~'! barePrimaryExpr;
barePrimaryExpr      = atomicValue | subSeqExpr | subTrackExpr;
subSeqExpr           = '(' expr ')'!;
subTrackExpr         = '[' expr ']'!;
atomicValue          = parser discard?;
parser               = variable | literal | pattern | delimitedString | constant;
discard              = '!'!;
pattern              = patternNoOpts | patternIgnoreCase;
patternNoOpts		 = %{'/', '/'};
patternIgnoreCase    = %{'/', '/i'};
delimitedString      = delimOpen QuotedString (','! QuotedString)? '}'!;
literal              = QuotedString;
constant             = 'Word' | 'Number' | 'QuotedString' | 'Symbol' | 'Comment' | 'Empty' | 'Any' | 'S' | 'Digit' | 'Letter' | 'Char' | 'SpecificChar';
variable             = Word;
delimOpen		     = '%{';