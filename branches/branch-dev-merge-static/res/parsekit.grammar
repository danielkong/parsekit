@start               = statement+;
statement            = beforeBlock | decl | tokenizerDirective;
tokenizerDirective   = '@'! Word '=' (Word | QuotedString)+ ';'!;
decl                 = production '=' action? expr ';'!;
production           = startProduction | varProduction;
startProduction      = '@'! 'start'!;
beforeBlock		     = '@'! beforeNaked action ';';
beforeNaked 		 = 'before'!;
varProduction        = Word;
expr                 = term orTerm*;
term                 = semanticPredicate? factor nextFactor*;
orTerm               = '|' term;
factor               = phrase (phraseStar | phrasePlus | phraseQuestion)? action?;

nextFactor           = factor;
phrase               = primaryExpr predicate*;

phraseStar = '*'!;
phrasePlus = '+'!;
phraseQuestion = '?'!;

action               = %{'{', '}'};
semanticPredicate    = %{'{', '}?'};

predicate            = (intersection | difference);
intersection         = '&'! primaryExpr;
difference           = '-'! primaryExpr;

primaryExpr          = negatedPrimaryExpr | barePrimaryExpr;
negatedPrimaryExpr   = '~'! barePrimaryExpr;
barePrimaryExpr      = atomicValue | subSeqExpr | subTrackExpr;
subSeqExpr           = '(' expr ')'!;
subTrackExpr         = '[' expr ']'!;
atomicValue          = parser discard?;
parser               = variable | literal | pattern | delimitedString | constant;
discard              = '!'!;
pattern              = patternNoOpts | patternIgnoreCase;
patternNoOpts		 = %{'/', '/'};
patternIgnoreCase    = %{'/', '/i'};
delimitedString      = delimOpen QuotedString (','! QuotedString)? '}'!;
literal              = QuotedString;
constant             = 'Word' | 'Number' | 'QuotedString' | 'Symbol' | 'Comment' | 'Empty' | 'Any' | 'S' | 'Digit' | 'Letter' | 'Char' | 'SpecificChar';
variable             = Word;
delimOpen		     = '%{';