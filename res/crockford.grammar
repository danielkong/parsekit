program
@before {
        PKTokenizer *t = self.tokenizer;
        
        // whitespace
		self.silentlyConsumesWhitespace = YES;
		t.whitespaceState.reportsWhitespaceTokens = YES;
		self.assembly.preservesWhitespaceTokens = YES;

        [t.symbolState add:@"||"];
        [t.symbolState add:@"&&"];
        [t.symbolState add:@"!="];
        [t.symbolState add:@"!=="];
        [t.symbolState add:@"=="];
        [t.symbolState add:@"==="];
        [t.symbolState add:@"<="];
        [t.symbolState add:@">="];
        [t.symbolState add:@"++"];
        [t.symbolState add:@"--"];
        [t.symbolState add:@"+="];
        [t.symbolState add:@"-="];
        [t.symbolState add:@"*="];
        [t.symbolState add:@"/="];
        [t.symbolState add:@"%="];
        [t.symbolState add:@"<<"];
        [t.symbolState add:@">>"];
        [t.symbolState add:@">>>"];
        [t.symbolState add:@"<<="];
        [t.symbolState add:@">>="];
        [t.symbolState add:@">>>="];
        [t.symbolState add:@"&="];
        [t.symbolState add:@"^="];
        [t.symbolState add:@"|="];

		// comments
        t.commentState.reportsCommentTokens = YES;
        
        [t setTokenizerState:t.commentState from:'/' to:'/'];
        [t.commentState addSingleLineStartMarker:@"//"];
        [t.commentState addMultiLineStartMarker:@"/*" endMarker:@"*/"];
		
	    // regex delimited strings
	    NSCharacterSet *nonWhitespace = [[NSCharacterSet whitespaceCharacterSet] invertedSet];
	    [t.delimitState addStartMarker:@"/" endMarker:@"/" allowedCharacterSet:nonWhitespace];
	    //[t.delimitState addStartMarker:@"/" endMarker:@"/i" allowedCharacterSet:nonWhitespace];		
}
	= (expr | stmts)*;
	;

arrayLiteral
	= '[' (expr (',' expr)*)? ']'
	;

block
	= '{' stmts? '}'
	;
	
breakStmt
	= 'break' name? ';' // name = label
	;
	
caseClause
	= ('case' expr ':')+ stmts
	;
	
disruptiveStmt
	= breakStmt
	| returnStmt
	| throwStmt
	;
	
doStmt
	= 'do' block 'while' '(' expr ')' ';'
	;
	
escapedChar
	= Symbol // TODO
	;

exponent
	= Number // TODO
	;

expr
	= literal
	| name
	| '(' expr ')'
	| prefixOp expr
	| expr (infixOp expr | '?' expr ':' expr | invocation | refinement)
	| 'new' expr invocation
	| 'delete' expr refinement
	;

exprStmt
	= (name refinement* '=')+ expr
	| name refinement* ('+=' | '-=') expr
	| name refinement* invocation+
	| 'delete' expr refinement
	;

forStmt
	= 'for'
	'(' 
	( exprStmt? ';' expr? ';' exprStmt? )
	|
	( name 'in' expr)
	')' block
	;

fraction
	= Number // TODO
	;

functionBody
	= '{' varStmts stmts '}'
	;

functionLiteral
	= 'function' name? parameters functionBody
	;

ifStmt 'if' '(' expr ')' block ('else' ifStmt? block)? // TODO worried about ifStmt recursion here
	= 
	;

infixOp
	= '*'
	| '/'
	| '%'
	| '+'
	| '-'
	| '>='
	| '<='
	| '>'
	| '<'
	| '==='
	| '!=='
	| '||'
	| '&&'
	;

integer
	= Number // TODO
	;

invocation
	= '(' (expr (',' expr)*)? ')'
	;

literal
	= numberLiteral
	| stringLiteral
	| objectLiteral
	| arrayLiteral
	| function
	| regexLiteral
	;

name
	= Word
	;

numberLiteral
	= Number
	;

objectLiteral
	= '{' (nameValPair (',' nameValPair)*)? '}'
	;
nameValPair // ADDED
	= (name|string) ':' expr
	;

parameters
	= '(' (name (',' name)*)? ')'
	;

prefixOp // TODO removed explicitly positive / negative numbers
	= 'typeof'
	| '!'
	;

refinement
	= '.' name
	| '[' expr ']'
	;

regexLiteral // TODO big changes to regex
	= %{'/', '/'} /[imxs]+/?
	;

returnStmt
	= 'return' expr? ';'
	;

stmts
    = stmt*;
    ;

stmt
    = (name ':')? // label
		( exprStmt ';'
		| disruptiveStmt
		| tryStmt
		| ifStmt
		| switchStmt
		| whileStmt
		| forStmt
		| doStmt
		)
	;

stringLiteral
	= QuotedString
	;

switchStmt
	= 'switch' '(' expr ')' '{' (caseClause disruptiveStmt?)+ ('default' ':' stmts)? '}'
	;

throwStmt
	= 'throw' expr ';'
	;

whileStmt
	= 'while' '(' expr ')' block
	;

varStmts
	= ('var' nameExprPair (',' nameExprPair)* ';')*
	;
nameExprPair // ADDED
	= name ('=' expr)?;

whileStmt
	= 'while' '(' expr ')' block
	;

whitespace // TODO
	= S
	;
