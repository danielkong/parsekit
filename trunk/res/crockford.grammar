program
@before {
        PKTokenizer *t = self.tokenizer;
        
        // whitespace
    //    self.silentlyConsumesWhitespace = YES;
    //    t.whitespaceState.reportsWhitespaceTokens = YES;
    //    self.assembly.preservesWhitespaceTokens = YES;

        [t.symbolState add:@"||"];
        [t.symbolState add:@"&&"];
        [t.symbolState add:@"!="];
        [t.symbolState add:@"!=="];
        [t.symbolState add:@"=="];
        [t.symbolState add:@"==="];
        [t.symbolState add:@"<="];
        [t.symbolState add:@">="];
        [t.symbolState add:@"++"];
        [t.symbolState add:@"--"];
        [t.symbolState add:@"+="];
        [t.symbolState add:@"-="];
        [t.symbolState add:@"*="];
        [t.symbolState add:@"/="];
        [t.symbolState add:@"%="];
        [t.symbolState add:@"<<"];
        [t.symbolState add:@">>"];
        [t.symbolState add:@">>>"];
        [t.symbolState add:@"<<="];
        [t.symbolState add:@">>="];
        [t.symbolState add:@">>>="];
        [t.symbolState add:@"&="];
        [t.symbolState add:@"^="];
        [t.symbolState add:@"|="];

        t.commentState.reportsCommentTokens = YES;
        
        [t setTokenizerState:t.commentState from:'/' to:'/'];
        [t.commentState addSingleLineStartMarker:@"//"];
        [t.commentState addMultiLineStartMarker:@"/*" endMarker:@"*/"];
}
	= element+
	;

arrayLiteral
	= '[' (expr (',' expr)*)? ']'
	;

block
	= '{' stmts? '}'
	;
	
breakStmt
	= 'break' name? ';' // name = label
	;
	
caseClause
	= ('case' expr ':')+ stmts
	;
	
disruptiveStmt
	= breakStmt
	| returnStmt
	| throwStmt
	;
	
doStmt
	= 'do' block 'while' '(' expr ')' ';'
	;
	
escapedChar
	= Symbol // TODO
	;

exponent
	= Number // TODO
	;

expr
	= literal
	| name
	| '(' expr ')'
	| prefixOp expr
	| expr (infixOp expr | '?' expr ':' expr | invocation | refinement)
	| 'new' expr invocation
	| 'delete' expr refinement
	;

exprStmt
	= (name refinement* '=')+ expr
	| name refinement* ('+=' | '-=') expr
	| name refinement* invocation+
	| 'delete' expr refinement
	;

forStmt
	= 'for'
	'(' 
	( exprStmt? ';' expr? ';' exprStmt? )
	|
	( name 'in' expr)
	')' block
	;

fraction
	= Number // TODO
	;

functionBody
	= '{' varStmts stmts '}'
	;

functionLiteral
	= 'function' name? parameters functionBody
	;

ifStmt 'if' '(' expr ')' block ('else' ifStmt? block)? // TODO worried about ifStmt recursion here
	= 
	;

infixOp
	= '*'
	| '/'
	| '%'
	| '+'
	| '-'
	| '>='
	| '<='
	| '>'
	| '<'
	| '==='
	| '!=='
	| '||'
	| '&&'
	;

integer
	= Number // TODO
	;

invocation
	= '(' (expr (',' expr)*)? ')'
	;

literal
	= numberLiteral
	| stringLiteral
	| objectLiteral
	| arrayLiteral
	| function
	| regexLiteral
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;

forStmt
	= 
	;
